
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - geometry - shapes</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        font-family: Monospace;
        background-color: #f0f0f0;
        margin: 0px;
        overflow: hidden;
      }
    </style>
  </head>
  <body>

    <script src="three.min.js"></script>
    <script src="stats.min.js"></script>
    <script src="dat.gui.min.js"></script>

    <script>

      var container, stats;

      var camera, scene, renderer;

      var targetRotation = 0;
      var targetRotationOnMouseDown = 0;

      var mouseX = 0;
      var mouseXOnMouseDown = 0;

      var windowHalfX = window.innerWidth / 2;
      var windowHalfY = window.innerHeight / 2;

      var resetMesh = function(value) {
        removeEntity("boxMesh");
        var boxMesh = createBox();
        scene.add(boxMesh);
        
        var bbox = new THREE.Box3().setFromObject(boxMesh);
        console.log(bbox.center());
        camera.position.set( bbox.center().x, bbox.center().y, 250 );
      }

      var boxParams = function() {
        this.boxDepth  = 50;
        this.boxHeight = 50;
        this.boxLength = 100;
      };

      var boxP = new boxParams();

      window.onload = function() {
        var gui = new dat.GUI();
        var controller 
        
        controller = gui.add(boxP, 'boxDepth', 10, 100);
        controller.onFinishChange(resetMesh);

        controller = gui.add(boxP, 'boxHeight', 10, 100);
        controller.onFinishChange(resetMesh);

        controller = gui.add(boxP, 'boxLength', 10, 100);
        controller.onFinishChange(resetMesh);


      };

      init();
      animate();

      function removeEntity(name) {
        var selectedObject = scene.getObjectByName(name);
        console.log(selectedObject);
        scene.remove( selectedObject );
        animate();
      }

      function createBox() {
        var box = [];
        var increments = [];
        var boxDepth  = boxP.boxDepth;
        console.log(boxDepth);
        var boxHeight = boxP.boxHeight;
        var boxLength = boxP.boxLength;
        var flapLength = (boxDepth / 2) * 0.8;
        var currentPoint = new THREE.Vector2(0,0);
        var cw = 2;

        //increments.push(new THREE.Vector3(flapLength + cw + boxLength + cw + flapLength, 0, 0));

        //increments.push(new THREE.Vector3(flapLength + cw + boxLength + cw + flapLength, 0, 0));
        increments.push(new THREE.Vector3(flapLength, 0, 0));
        increments.push(new THREE.Vector3(cw, 0, 0));
        increments.push(new THREE.Vector3(boxLength, 0, 0));
        increments.push(new THREE.Vector3(cw, 0, 0));
        increments.push(new THREE.Vector3(flapLength, 0, 0));

        increments.push(new THREE.Vector3(0, -boxHeight, 0));

        increments.push(new THREE.Vector3(-flapLength, 0, 0));

        increments.push(new THREE.Vector3(0, -cw, 0));

        increments.push(new THREE.Vector3(boxDepth + 2*cw + boxDepth + cw, 0, 0));

        increments.push(new THREE.Vector3(0, -boxHeight, 0));

        increments.push(new THREE.Vector3(-boxDepth, 0, 0));
        increments.push(new THREE.Vector3(-2*cw, 0, 0));
        increments.push(new THREE.Vector3(-boxDepth, 0, 0));
        increments.push(new THREE.Vector3(-cw, 0, 0));

        increments.push(new THREE.Vector3(0, -cw, 0));

        increments.push(new THREE.Vector3(flapLength, 0, 0));

        increments.push(new THREE.Vector3(0, -boxHeight, 0));

        increments.push(new THREE.Vector3(-flapLength, 0, 0));
        increments.push(new THREE.Vector3(-cw, 0, 0));
        increments.push(new THREE.Vector3(-boxLength, 0, 0));
        increments.push(new THREE.Vector3(-cw, 0, 0));
        increments.push(new THREE.Vector3(-flapLength, 0, 0));

        increments.push(new THREE.Vector3(0, boxHeight, 0));

        increments.push(new THREE.Vector3(flapLength, 0, 0));

        increments.push(new THREE.Vector3(0, cw, 0));

        //increments.push(new THREE.Vector3(-(boxDepth + 2*cw + boxDepth + cw), 0, 0));
        increments.push(new THREE.Vector3(-boxDepth, 0, 0));
        increments.push(new THREE.Vector3(-2*cw, 0, 0));
        increments.push(new THREE.Vector3(-boxDepth, 0, 0));
        increments.push(new THREE.Vector3(-cw, 0, 0));

        increments.push(new THREE.Vector3(0, boxHeight, 0));

        increments.push(new THREE.Vector3(boxDepth, 0, 0));
        increments.push(new THREE.Vector3(2*cw, 0, 0));
        increments.push(new THREE.Vector3(boxDepth, 0, 0));
        increments.push(new THREE.Vector3(cw, 0, 0));

        increments.push(new THREE.Vector3(0, cw, 0));

        increments.push(new THREE.Vector3(-flapLength, 0, 0));

        increments.push(new THREE.Vector3(0, boxHeight, 0));

        for( var i = 0; i < increments.length; i ++ ) {
          currentPoint.add(increments[i]);
          box.push( new THREE.Vector3(currentPoint.x, currentPoint.y, 0) ); 
        }

        var holes = [];
        var triangles = THREE.Shape.Utils.triangulateShape ( box, holes );
        var geometry = new THREE.Geometry();
        var material = new THREE.MeshBasicMaterial( { color: 0xf08000, wireframe: true, transparent: true } ); 

        //var material = new THREE.LineBasicMaterial({color:0xf08000});

        geometry.vertices = box;

        for( var i = 0; i < triangles.length; i++ ){
          geometry.faces.push( new THREE.Face3( triangles[i][0], triangles[i][1], triangles[i][2] ));
        }
        var mesh = new THREE.Mesh( geometry, material );
        mesh.name = "boxMesh";
        return mesh;

      }

      function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        var info = document.createElement( 'div' );
        info.style.position = 'absolute';
        info.style.top = '10px';
        info.style.width = '100%';
        info.style.textAlign = 'center';
        info.innerHTML = 'Simple procedurally generated 3D shapes<br/>Drag to spin';
        container.appendChild( info );

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.set( 50, -75, 250 );
        scene.add( camera );

        var light = new THREE.PointLight( 0xffffff, 0.8 );
        camera.add( light );
        var boxMesh = createBox();
        scene.add(boxMesh);
        
        var bbox = new THREE.Box3().setFromObject(boxMesh);
        console.log(bbox.center());
        camera.position.set( bbox.center().x, bbox.center().y, 250 );

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setClearColor( 0xf0f0f0 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );

        document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        document.addEventListener( 'touchstart', onDocumentTouchStart, false );
        document.addEventListener( 'touchmove', onDocumentTouchMove, false );

        window.addEventListener( 'resize', onWindowResize, false );

      }

      function onWindowResize() {

        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      //

      function onDocumentMouseDown( event ) {

        event.preventDefault();

        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        document.addEventListener( 'mouseup', onDocumentMouseUp, false );
        document.addEventListener( 'mouseout', onDocumentMouseOut, false );

        mouseXOnMouseDown = event.clientX - windowHalfX;
        targetRotationOnMouseDown = targetRotation;

      }

      function onDocumentMouseMove( event ) {

        mouseX = event.clientX - windowHalfX;

        targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.02;

      }

      function onDocumentMouseUp( event ) {

        document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
        document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
        document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

      }

      function onDocumentMouseOut( event ) {

        document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
        document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
        document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

      }

      function onDocumentTouchStart( event ) {

        if ( event.touches.length == 1 ) {

          event.preventDefault();

          mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
          targetRotationOnMouseDown = targetRotation;

        }

      }

      function onDocumentTouchMove( event ) {

        if ( event.touches.length == 1 ) {

          event.preventDefault();

          mouseX = event.touches[ 0 ].pageX - windowHalfX;
          targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;

        }

      }

      //

      function animate() {

        requestAnimationFrame( animate );

        render();
        stats.update();

      }

      function render() {
        renderer.render( scene, camera );
      }

    </script>

  </body>
</html>
