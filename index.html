
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Troquelator</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	</head>
  <body>

    <script src="three.min.js"></script>
    <script src="stats.min.js"></script>
    <script src="dat.gui.min.js"></script>
    <script src="box.js"></script>
		<script>


      var container, stats;

      var camera, scene, renderer;

      var targetRotation = 0;
      var targetRotationOnMouseDown = 0;

      var mouseX = 0;
      var mouseXOnMouseDown = 0;

      var windowHalfX = window.innerWidth / 2;
      var windowHalfY = window.innerHeight / 2;

      var boxP = new box();

      var updateBox = function(value) {

        var boxMesh = createBox();
				if (boxP.showMesh) {
					removeEntity("boxMesh");
					scene.add(boxMesh);
        
					var bbox = new THREE.Box3().setFromObject(boxMesh);
					console.log(bbox.center());
					camera.position.set( bbox.center().x, bbox.center().y, 250 );
				}
      }

      window.onload = function() {
        var gui = new dat.GUI();
        var controller;
        
        controller = gui.add(boxP, 'boxDepth', 10, 100);
        controller.onFinishChange(updateBox);

        controller = gui.add(boxP, 'boxHeight', 10, 100);
        controller.onFinishChange(updateBox);

        controller = gui.add(boxP, 'boxLength', 10, 100);
        controller.onFinishChange(updateBox);

        controller = gui.add(boxP, 'cardboardWidth', 1, 3);
        controller.onFinishChange(updateBox);

				//gui.add(boxP,'showMesh');
        //gui.add(boxP,'createSVG');
      };

			
      init();
			if (boxP.showMesh) {
				animate();
			}

      function removeEntity(name) {
        var selectedObject = scene.getObjectByName(name);
        console.log(selectedObject);
        scene.remove( selectedObject );
        animate();
      }

      function createBox() {
        var box = [];
        var increments = boxP.boxGeometry();
				boxP.createSVG(increments, boxP.createFoldMarks(), boxP.createHoles());
				
				if (boxP.showMesh) {
					var currentPoint = new THREE.Vector2(0,0);

					for( var i = 0; i < increments.length; i ++ ) {
						currentPoint.add(increments[i]);
						box.push( new THREE.Vector3(currentPoint.x, currentPoint.y, 0) ); 
					}

					var holes = [];
					var triangles = THREE.Shape.Utils.triangulateShape ( box, holes );
					var geometry = new THREE.Geometry();
					var material = new THREE.MeshBasicMaterial({color: 0xf08000, wireframe: true, transparent: true}); 

					geometry.vertices = box;

					for( var i = 0; i < triangles.length; i++ ){
						geometry.faces.push( new THREE.Face3( triangles[i][0], triangles[i][1], triangles[i][2] ));
					}
					var mesh = new THREE.Mesh( geometry, material );
					mesh.name = "boxMesh";
					return mesh;
				} else {
					return null;
				}
      }

      function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        var info = document.createElement( 'h2' );
        info.style.position = 'absolute';
        info.style.top = '5px';
        info.style.width = '100%';
        info.style.textAlign = 'center';
        info.innerHTML = 'Troquelator';
        container.appendChild( info );

				var boxMesh = createBox();
				if (boxP.showMesh) {
					scene = new THREE.Scene();

					camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
					camera.position.set( 50, -75, 250 );
					scene.add( camera );

					var light = new THREE.PointLight( 0xffffff, 0.8 );
					camera.add( light );
					scene.add(boxMesh);
        
					var bbox = new THREE.Box3().setFromObject(boxMesh);
					console.log(bbox.center());
					camera.position.set( bbox.center().x, bbox.center().y, 250 );

					renderer = new THREE.WebGLRenderer( { antialias: true } );
					renderer.setClearColor( 0xf0f0f0 );
					renderer.setPixelRatio( window.devicePixelRatio );
					renderer.setSize( window.innerWidth, window.innerHeight );
					container.appendChild( renderer.domElement );

					stats = new Stats();
					stats.domElement.style.position = 'absolute';
					stats.domElement.style.top = '0px';
					container.appendChild( stats.domElement );

					document.addEventListener( 'mousedown', onDocumentMouseDown, false );
					document.addEventListener( 'touchstart', onDocumentTouchStart, false );
					document.addEventListener( 'touchmove', onDocumentTouchMove, false );

					window.addEventListener( 'resize', onWindowResize, false );
				}
      }

      function onWindowResize() {

        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      function onDocumentMouseDown( event ) {

        event.preventDefault();

        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        document.addEventListener( 'mouseup', onDocumentMouseUp, false );
        document.addEventListener( 'mouseout', onDocumentMouseOut, false );

        mouseXOnMouseDown = event.clientX - windowHalfX;
        targetRotationOnMouseDown = targetRotation;

      }

      function onDocumentMouseMove( event ) {
        mouseX = event.clientX - windowHalfX;
      }

      function onDocumentMouseUp( event ) {
        document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
        document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
        document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
      }

      function onDocumentMouseOut( event ) {
        document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
        document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
        document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
      }

      function onDocumentTouchStart( event ) {
        if ( event.touches.length == 1 ) {
          event.preventDefault();
          mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
        }
      }

      function onDocumentTouchMove( event ) {

        if ( event.touches.length == 1 ) {
          event.preventDefault();
          mouseX = event.touches[ 0 ].pageX - windowHalfX;
        }
      }

      function animate() {
        requestAnimationFrame( animate );
        render();
        stats.update();
      }

      function render() {
        renderer.render( scene, camera );
      }

    </script>

  </body>
</html>
